<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <meta charset="utf-8" />
  <title>stemsplat</title>

  <!-- nunito sans -->
  <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@300;400;600&display=swap" rel="stylesheet">

  <!-- tailwind (cdn build) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root {
      --bg-1: #0F2027;   /* emerald dusk left */
      --bg-2: #2C5364;   /* emerald dusk right */
      --txt-main: #E7ECEF;
      --txt-dim: #B8C4CC;
      --accent:  #8ED8FF; /* subtle cyan accent for highlights only */
      --icon:   #9BB6C2;
      --card: rgba(23, 35, 41, 0.55);
      --card-done: rgba(40, 66, 77, 0.70);
      --border: rgba(255,255,255,0.06);
    }
    /* Animated light blur for settings overlay BACKGROUND (not the card) */
    @keyframes overlayBlurIn {
      from { backdrop-filter: blur(0px); -webkit-backdrop-filter: blur(0px); background-color: rgba(0, 0, 0, 0.0); }
      to   { backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px); background-color: rgba(0, 0, 0, 0.35); }
    }
    .overlay-bg {
      position: fixed;
      inset: 0;
      pointer-events: none;
      backdrop-filter: blur(0px);
      -webkit-backdrop-filter: blur(0px);
      background-color: rgba(0, 0, 0, 0.0);
    }
    .overlay-bg.anim     { animation: overlayBlurIn .28s ease both; }
    @keyframes overlayBlurOut {
      from { backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px); background-color: rgba(0, 0, 0, 0.35); }
      to   { backdrop-filter: blur(0px); -webkit-backdrop-filter: blur(0px); background-color: rgba(0, 0, 0, 0.0); }
    }
    .overlay-bg.anim-out { animation: overlayBlurOut 0.18s ease both; }
    @keyframes settingsCardIn {
      from { opacity: 0; transform: translateY(8px) scale(0.98); }
      to   { opacity: 1; transform: translateY(0)    scale(1.00); }
    }
    @keyframes settingsCardOut {
      from { opacity: 1; transform: translateY(0)    scale(1.00); }
      to   { opacity: 0; transform: translateY(6px)  scale(0.98); }
    }
    .settings-card-in  { animation: settingsCardIn  .28s cubic-bezier(.2,.7,.2,1) both; }
    .settings-card-out { animation: settingsCardOut .18s ease both; }

    body { background: linear-gradient(135deg, #0B1A1F 0%, var(--bg-1) 35%, var(--bg-2) 100%); padding-top:48px; padding-bottom:48px; }

    .noise::before { content: ""; position: fixed; inset: 0; pointer-events: none;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120" viewBox="0 0 120 120"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" stitchTiles="stitch"/></filter><rect width="120" height="120" filter="url(%23n)" opacity="0.035"/></svg>') repeat; opacity:.18; }
    .shade { position: fixed; inset: 0; pointer-events: none; background: rgba(0,0,0,0.24); z-index: -1; }

    .glass { background: var(--card); backdrop-filter: blur(12px) saturate(110%); -webkit-backdrop-filter: blur(12px) saturate(110%); border: 1px solid var(--border); box-shadow: 0 8px 26px rgba(0,0,0,.28); }
    .glass-light { background: rgba(255,255,255,0.12); backdrop-filter: blur(10px) saturate(110%); -webkit-backdrop-filter: blur(10px) saturate(110%); border: 1px solid rgba(255,255,255,0.18); box-shadow: 0 8px 26px rgba(0,0,0,.28); }
    .card   { position: relative; overflow: visible; transition: background .20s ease; will-change: transform, opacity; transform: translateZ(0); contain: paint; flex-shrink: 0; }
    .card:hover { box-shadow: 0 8px 26px rgba(0,0,0,.28); }
    .card:has(.dl-pad:hover):hover { box-shadow: 0 12px 40px rgba(0,0,0,.35); }
    .card.done { background: var(--card-done); }

    #title { letter-spacing: 0.5px; text-shadow: 0 8px 40px rgba(0,0,0,.45); }

    .fade-in { animation: fade .7s ease forwards; }
    @keyframes fade { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .btn { display:inline-flex; align-items:center; justify-content:center; border-radius:12px; padding:6px 10px; font-size:12px; font-weight:600; transition: transform .15s ease, box-shadow .15s ease; }
    .btn:focus { outline: 2px solid rgba(255,255,255,.25); outline-offset: 2px; }
    .btn:hover { transform: translateY(-1px); }

    .close-btn { position: fixed; top: 14px; left: 14px; width: 40px; height: 40px; border-radius: 12px; background: rgba(255,255,255,0.14); border:1px solid rgba(255,255,255,0.12); color: #E7ECEF; backdrop-filter: blur(10px) saturate(120%); -webkit-backdrop-filter: blur(10px) saturate(120%); box-shadow: 0 10px 30px rgba(0,0,0,.25); display: grid; place-items: center; font-size: 18px; transition: transform .18s ease, box-shadow .18s ease, background .18s ease; z-index: 20; }
    .close-btn:hover { transform: translateY(-2px); box-shadow: 0 14px 34px rgba(0,0,0,.35); background: rgba(255,255,255,0.22); }

    .chip { font-size:11px; padding:3px 8px; border-radius:999px; color: #ffffff; background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18); }
    .chip-dim { background: rgba(0,0,0,.38); border:1px solid rgba(255,255,255,.10); color:#E7ECEF; }

    .bar { height: 10px; background: rgba(255,255,255,.08); border-radius:999px; overflow: hidden; }
    .bar-fill { height:100%; width:0%; background: linear-gradient(90deg, #e7eef2, #dfe7ec); will-change: width; }

    /* pretty checkboxes */
    input.pretty{ appearance:none; -webkit-appearance:none; width:18px; height:18px; border:1.5px solid rgba(255,255,255,.35); border-radius:6px; background: transparent; display:inline-grid; place-items:center; transition: all .18s ease; }
    input.pretty:hover{ border-color: rgba(255,255,255,.6); box-shadow: 0 0 0 3px rgba(255,255,255,.06) inset; }
    input.pretty:checked{ background: linear-gradient(135deg, #96c5d6, #5fa3b5); border-color: transparent; }
    input.pretty:checked::after{ content:""; width:6px; height:10px; border:2px solid #0F2027; border-top:0; border-left:0; transform: rotate(45deg); }

    #top-vig, #bot-vig { pointer-events:none; position:fixed; left:0; right:0; height:48px; background:linear-gradient(to bottom,rgba(0,0,0,.45),transparent); opacity:0; transition:opacity .25s ease; }
    #top-vig{ top:0; bottom:auto; transform:none; }
    #bot-vig{ top:auto; bottom:0; transform:rotate(180deg); }

    .dl-pad,
    .stop-pad { width:56px; height:56px; border-radius:14px; background: rgba(255,255,255,0.95); color:#0F2027; display:flex; align-items:center; justify-content:center; box-shadow:0 8px 20px rgba(0,0,0,.28); opacity:0; transform: translateX(-10px); transition: opacity .42s ease, transform .42s ease, box-shadow .20s ease; pointer-events:none; align-self: center; position: absolute; top: 50%; transform: translateY(-50%); }
    .dl-pad.show,
    .stop-pad.show { opacity:1; transform: translateX(0) translateY(-50%); pointer-events:auto; }
    .dl-pad:hover,
    .stop-pad:hover { box-shadow:0 12px 30px rgba(0,0,0,.35); }
    .item-row { position: relative; padding-right: 84px; }
    .dl-pad { right: 12px; }
    .stop-pad { right: 12px; }
    .dl-pad svg, .stop-pad svg { display:block; margin:auto; }

    @keyframes breathe { 0%{transform:translateY(0)} 50%{transform:translateY(-2px)} 100%{transform:translateY(0)} }
    .micro { animation: breathe 3s ease-in-out infinite; }
    .slide-out { opacity: 0; transform: translateY(-10px); transition: transform .35s ease-in-out, opacity .35s ease-in-out; }
    .enter-pre { opacity: 0; transform: translateY(8px); }
    .enter-active { opacity: 1; transform: translateY(0); transition: transform .35s ease-in-out, opacity .35s ease-in-out; }
    /* leave/fade/slide transition for queue items */
    .leave { opacity: 1; transform: translateY(0); }
    .leave-active { transition: transform .16s ease-in-out, opacity .16s ease-in-out; }
    .leave-to { opacity: 0; transform: translateY(-2px); }
    #clear-btn { opacity: 0; transition: opacity .25s ease; }
    #clear-btn.show { opacity: 1; }
    #queue-spacer { height: 0; transition: height .18s ease-in-out; will-change: height; }
    .fade { transition: opacity .20s ease; }

    
    .page-mask { position:fixed; inset:0; background: rgba(0,0,0,0.0); pointer-events:none; opacity:0; transition: opacity .28s ease; }
    .page-mask.show { opacity:1; }
@media (prefers-reduced-motion: reduce){ .fade-in{ animation:none; } .btn:hover{ transform:none; } .card:hover{ transform:none; } .micro{ animation:none; } }
    /* Prevent flashing UI before intro animation */
    .intro .pre-hide{ opacity: 0; }
    @view-transition { navigation: auto; }
  </style>

  <script>
    if (localStorage.getItem('playIntro')) {
      document.documentElement.classList.add('intro');
    }
  </script>
</head>

<body class="min-h-screen flex flex-col items-center justify-center gap-10" style="font-family: 'Nunito Sans', sans-serif;">

  <div class="noise fixed inset-0 -z-10"></div>
  <div class="shade"></div>
  <button id="close-app" class="close-btn" title="close stemsplat" aria-label="close">
    ×
  </button>

  <!-- header -->
  <h1 id="title" class="text-5xl md:text-6xl font-light text-[var(--txt-main)] select-none tracking-tight">stemsplat</h1>
  <!-- controls -->
  <div class="w-11/12 max-w-3xl flex gap-6">
    <label id="dropzone" for="file-input" class="glass pre-hide relative flex-1 px-10 py-14 rounded-3xl text-center fade-in flex flex-col items-center justify-center gap-6 cursor-pointer transition-transform duration-200 hover:scale-105" role="button" tabindex="0">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-14 h-14 stroke-[var(--icon)]" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
        <path stroke-linecap="round" stroke-linejoin="round" d="M12 15V9m0 0l3 3m-3-3L9 12m3 9a9 9 0 110-18 9 9 0 010 18z" />
      </svg>
      <p class="text-lg text-[var(--txt-main)]">drag audio here <br>or click to choose files</p>
      <input id="file-input" type="file" accept="audio/*" multiple aria-label="choose audio files" class="sr-only" />
    </label>
    <div class="flex flex-col gap-4 w-64">
      <div id="stems-card" class="glass pre-hide w-64 p-6 rounded-3xl flex flex-col gap-2 fade-in text-[var(--txt-main)]/90 relative">
        <button id="settings-btn" title="settings" class="absolute top-3 right-3 z-10 p-2 rounded-lg hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-white/30 cursor-pointer">
          <svg viewBox="0 0 24 24" class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h0A1.65 1.65 0 0 0 9 3.09V3a2 2 0 1 1 4 0v.09c0 .65.38 1.24.97 1.51h0a1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06c-.47.47-.61 1.18-.33 1.82h0c.27.6.86.97 1.51.97H21a2 2 0 1 1 0 4h-.09c-.65 0-1.24.38-1.51.97Z"></path>
          </svg>
        </button>
        <p class="text-sm text-[var(--txt-main)] mt-0">stems</p>
        <label class="flex items-center gap-2 text-[var(--txt-main)]"><input id="vocals-box" type="checkbox" class="pretty" checked>vocals (fastest)</label>
        <label class="flex items-center gap-2 text-[var(--txt-main)]"><input id="inst-box" type="checkbox" class="pretty">instrumental (fastest)</label>
        <label class="flex items-center gap-2 text-[var(--txt-main)]"><input id="deux-box" type="checkbox" class="pretty">both (highest quality)</label>
      </div>
      <button id="start-btn" class="glass-light pre-hide w-64 px-6 py-4 rounded-3xl flex flex-col items-center justify-center fade-in focus:outline-none focus:ring-2 focus:ring-white/30 text-white disabled:opacity-50 disabled:cursor-not-allowed">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7 micro" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 5v14l11-7z"/>
        </svg>
        <span class="btn-title mt-1 text-sm font-semibold">start</span>
      </button>
    </div>
  </div>

  <!-- queue -->
  <div id="queue" class="pre-hide w-11/12 max-w-2xl flex flex-col gap-4"></div>
  <div id="queue-spacer" class="w-11/12 max-w-2xl"></div>
  <button id="clear-btn" class="pre-hide mt-4 text-white underline">clear all</button>
  <div id="queue-bottom-pad" class="w-11/12 max-w-2xl"></div>
  <div id="top-vig"></div>
  <div id="bot-vig"></div>

  <!-- templates & scripts -->
  <template id="item-template">
    <div class="item-row flex items-center gap-3">
      <div class="glass card rounded-xl px-6 py-4 flex-1 flex flex-col gap-3">
        <div class="flex justify-between items-center gap-3">
          <div class="flex items-center gap-2 min-w-0">
            <span class="truncate text-[var(--txt-main)] text-sm filename"></span>
            <div class="labels flex items-center gap-1"></div>
          </div>
          <div class="flex items-center gap-3">
            <span class="chip status">queued</span>
          </div>
        </div>
        <div class="bar"><div class="bar-fill progress"></div></div>
      </div>
      <button class="dl-pad self-center" type="button" title="open folder">
        <svg viewBox="0 0 24 24" class="w-7 h-7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 7h5l2 3h11v9H3z"/>
          <path d="M3 7v12"/>
        </svg>
      </button>
      <a class="stop-pad self-center" href="#" title="stop" style="display:none;">
        <!-- square icon -->
        <svg viewBox="0 0 24 24" class="w-7 h-7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="6" y="6" width="12" height="12"/>
        </svg>
      </a>
    </div>
  </template>

  <script>
    /* helpers */
    const MAX_TASKS = 50;
    const STORAGE_WARN_GB = 1;
    const STORAGE_BLOCK_GB = 0.5;
    const MEMORY_LIMIT_RATIO = 0.9;
    const MEMORY_LIMIT_MB = 700;
    const FIVE_HOURS_SEC = 5 * 60 * 60;
    const LONG_TRACK_SEC = 15 * 60;

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('file-input');
    const vocalsBox = document.getElementById('vocals-box');
    const instBox   = document.getElementById('inst-box');
    const deuxBox   = document.getElementById('deux-box');
    const queue     = document.getElementById('queue');
    const clearBtn  = document.getElementById('clear-btn');
    const topVig    = document.getElementById('top-vig');
    const botVig    = document.getElementById('bot-vig');
    const bottomPad = document.getElementById('queue-bottom-pad');
    const template  = document.getElementById('item-template');
    const title     = document.getElementById('title');
    const spacer    = document.getElementById('queue-spacer');
    const closeBtn  = document.getElementById('close-app');
    const startBtn  = document.getElementById('start-btn');
    const outputInput = null;
    const outputChoose = null;
    const structureCheck = null;
    const structurelessCheck = null;
    let storageBlocked = false;
    let memoryBlocked = false;
    let lastStorageWarning = 0;
    let lastMemoryWarning = 0;

    let startPressed = false;
    let startGeneration = 0;
    let startLock = false;
    let settingsState = { output_root: '', structure_mode: 'flat' };
    let defaultOutputPath = '';
    let dirPickerInput = null;
    updateStartButton();
    function updateStartButton(){
      if(!startBtn) return;
      const hasItems = queue.children.length > 0;
      if(!hasItems || startLock || storageBlocked || memoryBlocked){
        startBtn.disabled = true;
        const icon = startBtn.querySelector('svg');
        if(icon){ icon.style.animation = 'none'; }
      }else{
        startBtn.disabled = false;
        const icon = startBtn.querySelector('svg');
        if(icon){ icon.style.animation = ''; }
      }
    }

    if (closeBtn) {
      const shutdownEndpoints = [
        { url: '/shutdown', options: { method: 'POST', keepalive: true } },
        { url: 'http://localhost:6060/installer_shutdown', options: { method: 'POST', mode: 'no-cors', keepalive: true } },
      ];
      const sendShutdown = async () => {
        const tasks = shutdownEndpoints.map(({ url, options }) => (
          fetch(url, options).catch(() => {
            try { navigator.sendBeacon(url, new Blob()); } catch(_) {}
          })
        ));
        await Promise.allSettled(tasks);
      };
      const closeWindow = () => {
        try { window.close(); } catch(_) {}
        window.location.replace('about:blank');
      };
      closeBtn.addEventListener('click', async () => {
        closeBtn.disabled = true;
        closeBtn.style.opacity = '0.7';
        try {
          const hasRunning = Array.isArray(tasks) && tasks.some(t => isProcessing(t));
          if(hasRunning){
            const ok = await showConfirm('A process is still running. Close anyway?');
            if(!ok){
              closeBtn.disabled = false;
              closeBtn.style.opacity = '';
              return;
            }
          }
          await clearAllTasks();
          await sendShutdown();
        } catch (err) {
          console.error('shutdown failed', err);
        }
        setTimeout(closeWindow, 220);
      });
    }

    function applySettingsUI(){
      // settings UI disabled; outputs always go to default zip
    }

    function guardClick(el, handler, cooldown = 600){
      if(!el || typeof handler !== 'function') return;
      if(el.__guardedHandler){
        el.removeEventListener('click', el.__guardedHandler);
      }
      let busy = false;
      const wrapped = async (e) => {
        if(busy){
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        busy = true;
        try{
          await handler(e);
        }finally{
          setTimeout(() => { busy = false; }, cooldown);
        }
      };
      el.__guardedHandler = wrapped;
      el.addEventListener('click', wrapped);
    }

    async function loadSettings(){
      try{
        const res = await fetch('/settings');
        if(!res.ok) return;
        const data = await res.json();
        settingsState = { ...settingsState, ...data };
        defaultOutputPath = data.output_root || defaultOutputPath;
        applySettingsUI();
      }catch(err){
        console.warn('failed to load settings', err);
      }
    }

    async function persistSettings(patch, {showMissingPopup = true} = {}){
      settingsState = { ...settingsState, ...patch };
      try{
        const res = await fetch('/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(settingsState),
        });
        if(!res.ok){
          if(showMissingPopup) showPopup("folder doesn't exist");
          await loadSettings();
          return;
        }
        const data = await res.json();
        settingsState = { ...settingsState, ...data };
        defaultOutputPath = defaultOutputPath || data.output_root;
        applySettingsUI();
      }catch(err){
        console.warn('settings update failed', err);
        if(showMissingPopup) showPopup("folder doesn't exist");
        await loadSettings();
      }
    }

    async function checkStorage(){
      if(!navigator.storage || !navigator.storage.estimate) return true;
      try{
        const {usage = 0, quota = 0} = await navigator.storage.estimate();
        const free = Math.max(0, quota - usage);
        const freeGb = free / (1024 ** 3);
        if(freeGb < STORAGE_BLOCK_GB){
          storageBlocked = true;
          showPopup('storage critically low (<0.5 GB). uploads are blocked');
          updateStartButton();
          return false;
        }
        if(freeGb < STORAGE_WARN_GB){
          const now = Date.now();
          if(now - lastStorageWarning > 10000){
            showPopup('storage low (<1 GB remaining)');
            lastStorageWarning = now;
          }
        }
        storageBlocked = false;
        updateStartButton();
      }catch(_){}
      return !storageBlocked;
    }

    function checkMemory(){
      const perf = performance || window.performance;
      const mem = perf && perf.memory;
      if(!mem) return true;
      const { jsHeapSizeLimit = 0, usedJSHeapSize = 0 } = mem;
      const limit = jsHeapSizeLimit ? jsHeapSizeLimit * MEMORY_LIMIT_RATIO : MEMORY_LIMIT_MB * 1024 * 1024;
      if(usedJSHeapSize > limit){
        memoryBlocked = true;
        const now = Date.now();
        if(now - lastMemoryWarning > 10000){
          showPopup('memory use is high; uploads paused to prevent leaks');
          lastMemoryWarning = now;
        }
        updateStartButton();
        return false;
      }
      memoryBlocked = false;
      updateStartButton();
      return true;
    }

    function estimateDecodeMb(seconds){
      // Roughly 0.34 MB/sec for 44.1kHz stereo float
      return seconds * 0.34;
    }

    function hasMemoryForDuration(seconds){
      if(seconds <= LONG_TRACK_SEC) return true;
      const perf = performance || window.performance;
      const mem = perf && perf.memory;
      if(!mem || !mem.jsHeapSizeLimit) return true;
      const { jsHeapSizeLimit = 0, usedJSHeapSize = 0 } = mem;
      const freeMb = Math.max(0, jsHeapSizeLimit - usedJSHeapSize) / (1024 * 1024);
      const needMb = estimateDecodeMb(seconds) * 1.5; // headroom
      if(freeMb <= needMb){
        showPopup('song is too long for available memory right now');
        return false;
      }
      return true;
    }

    function getAudioDuration(file){
      return new Promise((resolve) => {
        let url = null;
        try{
          const audio = document.createElement('audio');
          audio.preload = 'metadata';
          url = URL.createObjectURL(file);
          const cleanup = () => {
            if(url){ URL.revokeObjectURL(url); url = null; }
            audio.removeAttribute('src');
            audio.load();
          };
          const timeout = setTimeout(() => { cleanup(); resolve(-1); }, 3000);
          audio.onloadedmetadata = () => {
            clearTimeout(timeout);
            const d = audio.duration;
            cleanup();
            resolve(isFinite(d) ? d : -1);
          };
          audio.onerror = () => { clearTimeout(timeout); cleanup(); resolve(-1); };
          audio.src = url;
        }catch(_){
          if(url){ URL.revokeObjectURL(url); }
          resolve(-1);
        }
      });
    }

    // settings overlay refs (assigned on load)
    let settingsOverlay = null;
    function openSettings(){
      if(!settingsOverlay) settingsOverlay = document.getElementById('settings-overlay');
      const bg = document.getElementById('overlay-bg');
      const card = document.getElementById('settings-card');
      if(settingsOverlay){
        settingsOverlay.classList.remove('hidden');
        if(bg){
          bg.classList.remove('anim-out');
          bg.classList.remove('anim');
          void bg.offsetWidth;
          bg.classList.add('anim'); // IN
        }
        if(card){
          card.classList.remove('settings-card-out');
          card.classList.remove('opacity-0');
          void card.offsetWidth;
          card.classList.add('settings-card-in'); // IN
        }
      }
    }
    function closeSettings(){
      if(!settingsOverlay) settingsOverlay = document.getElementById('settings-overlay');
      const bg = document.getElementById('overlay-bg');
      const card = document.getElementById('settings-card');
      if(settingsOverlay){
        if(bg){
          bg.classList.remove('anim');
          bg.classList.remove('anim-out');
          void bg.offsetWidth;
          bg.classList.add('anim-out'); // OUT
        }
        if(card){
          card.classList.remove('settings-card-in');
          card.classList.remove('fade-in');
          card.classList.add('settings-card-out'); // OUT
        }
        setTimeout(() => {
          if(card){
            card.classList.remove('settings-card-out');
            card.classList.add('opacity-0');
          }
          if(bg){ bg.classList.remove('anim-out'); }
          settingsOverlay.classList.add('hidden');
        }, 180);
      }
    }

    // --- Progress Smoother Helper ---
    function makeProgressSmoother(bar){
      let raf = null;
      let value = 0;     // currently displayed percent
      let target = 0;    // latest requested percent
      const clamp = p => Math.max(0, Math.min(100, p));
      const tick = () => {
        // critically damped-ish exponential approach toward target
        const delta = target - value;
        // if close enough, snap to target and stop
        if (Math.abs(delta) < 0.08) {
          value = target;
          bar.style.width = value + '%';
          raf = null;
          return;
        }
        // ease toward target; 0.12 controls lag/smoothness
        value += delta * 0.12;
        bar.style.width = value + '%';
        raf = requestAnimationFrame(tick);
      };
      return {
        setImmediate(p){ value = target = clamp(p); bar.style.width = value + '%'; },
        setTarget(p){ target = clamp(p); if(!raf) raf = requestAnimationFrame(tick); },
        stop(){ if(raf){ cancelAnimationFrame(raf); raf = null; } }
      };
    }

    if(localStorage.getItem('playIntro')){
      localStorage.removeItem('playIntro');
      title.style.position = 'absolute';
      title.style.left = '50%';
      title.style.top = '45%';
      title.style.transform = 'translate(-50%, -50%)';
      title.style.opacity = '1';
      setTimeout(() => {
        title.style.transition = 'all 0.5s ease';
        title.style.left = '';
        title.style.top = '';
        title.style.transform = '';
      }, 50);
      setTimeout(() => {
        document.querySelectorAll('#dropzone, .glass.w-64, #queue, #clear-btn').forEach((el,i)=>{
          setTimeout(()=>{el.classList.add('fade-in')}, i*25);
        });
      }, 600);
    } else {
      title.classList.add('fade-in');
    }

    let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
    // Helper: is a task finished? (completed or stopped)
    function isFinished(t){
      return t && (t.pct >= 100 || t.stage === 'stopped');
    }
    function saveTasks(){ localStorage.setItem('tasks', JSON.stringify(tasks)); }

    async function rehydrateTasks(){
      if(!Array.isArray(tasks) || tasks.length === 0) return;
      try{
        const res = await fetch('/rehydrate_tasks', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ tasks })
        });
        if(!res.ok) return;
        const data = await res.json();
        if(!data || !Array.isArray(data.tasks)) return;
        const keep = new Set();
        data.tasks.forEach(t => {
          if(!t || !t.id) return;
          const idx = tasks.findIndex(x => x && x.id === t.id);
          const merged = idx >= 0 ? { ...tasks[idx], ...t } : t;
          if(idx >= 0) tasks[idx] = merged;
          else tasks.push(merged);
          keep.add(t.id);
        });
        // drop any tasks that were not completed on disk (e.g., force-quit)
        tasks = tasks.filter(t => t && keep.has(t.id));
        saveTasks();
      }catch(err){
        console.debug('rehydration skipped', err);
      }
    }
    // processing-state helper
    function isProcessing(t){
      if(!t) return false;
      const stage = (t.stage || '').toLowerCase();
      const inactive = ['ready','queued','done','stopped','error'];
      if(inactive.includes(stage)) return false;
      return typeof t.pct === 'number' ? (t.pct >= 0 && t.pct < 100) : true;
    }
    
    function updateClear(){
      let hasClearable = false;
      if (!startPressed) {
        hasClearable = Array.isArray(tasks) && tasks.length > 0;
      } else {
        hasClearable = tasks && tasks.some(t => t && (t.stage === 'stopped' || (typeof t.pct === 'number' && t.pct >= 100)));
      }
      const manyItems = queue.children.length > 6;
      // Reserve fixed vertical space to avoid layout jump whether visible or not
      spacer.style.height = hasClearable ? '18px' : '12px';
      if (bottomPad) {
        bottomPad.style.height = manyItems ? '110px' : '52px';
      }
      if (hasClearable) {
        clearBtn.classList.add('show');
        clearBtn.style.pointerEvents = 'auto';
      } else {
        clearBtn.classList.remove('show');
        clearBtn.style.pointerEvents = 'none';
      }
    }
    function updateVigs(){
      const rect = queue.getBoundingClientRect();
      topVig.style.top = '0px';
      topVig.style.bottom = 'auto';
      topVig.style.transform = 'none';
      topVig.style.opacity = window.scrollY > 0 ? '1' : '0';
      botVig.style.opacity = rect.bottom > window.innerHeight ? '1' : '0';
    }

    function enforceCapacity(){
      const activeCount = tasks.filter(t => t && !isFinished(t)).length;
      const full = activeCount >= MAX_TASKS;
      dropzone.classList.toggle('pointer-events-none', full);
      dropzone.classList.toggle('opacity-60', full);
      if(fileInput) fileInput.disabled = full;
      if(full){
        const now = Date.now();
        if(!enforceCapacity._lastNotice || now - enforceCapacity._lastNotice > 8000){
          showPopup('maximum number of songs reached! Please clear all to upload more songs');
          enforceCapacity._lastNotice = now;
        }
      }
      return full;
    }

    function updateUI(){
      updateClear();
      updateVigs();
      updateStartButton();
      enforceCapacity();
    }


    // Helper to apply stem labels
    function applyLabels(container, stemsList){
      if(!container || !stemsList) return;
      container.innerHTML='';
      const pretty = { deux: 'both' };
      stemsList.forEach(name => {
        const base = name.split(' - ').pop() || name;
        const stem = base.replace(/\.wav$/i,'');
        const chip = document.createElement('span');
        chip.className = 'chip chip-dim text-[11px]';
        chip.textContent = pretty[stem] || stem;
        container.appendChild(chip);
      });
    }

    function shouldShowStatus(stage){
      const active = stage && stage !== 'ready' && stage !== 'queued';
      return startPressed || active;
    }

    function setStatusVisibility(st, stage){
      if(!st) return;
      const visible = stage !== 'done' && shouldShowStatus(stage);
      st.classList.toggle('hidden', !visible);
    }

    function hideStatus(st){
      if(!st) return;
      st.textContent = '';
      st.classList.add('hidden');
      st.style.display = 'none';
    }

    function showStatus(st){
      if(!st) return;
      st.style.display = '';
    }

    function setStopVisibility(stopPad, stage, forceShow = false){
      if(!stopPad) return;
      const active = forceShow || (stage && !['ready','queued','done','stopped','error','errored'].includes(stage));
      const show = !!active;
      stopPad.style.display = show ? '' : 'none';
      stopPad.classList.toggle('show', show);
      if(!show){
        stopPad.style.pointerEvents = 'none';
        stopPad.style.opacity = '0.6';
      } else {
        stopPad.style.pointerEvents = '';
        stopPad.style.opacity = '';
      }
    }

    function bindFolderButton(btn, taskRef){
      if(!btn || !taskRef) return;
      guardClick(btn, async (e) => {
        e.preventDefault();
        if(btn.dataset.busy === '1') return;
        btn.dataset.busy = '1';
        try{
          const res = await fetch('/reveal/' + taskRef.id, { method: 'POST' });
          if(!res.ok){
            const msg = taskRef.out_dir ? `folder missing: ${taskRef.out_dir}` : 'output not ready';
            showPopup(msg);
          }
        }catch(err){
          showPopup('output not ready');
        }
        setTimeout(() => { btn.dataset.busy = ''; }, 250);
      });
    }

    // --- Helper to set rerun and stop icons ---
    
    function setRetryIcon(stopPad){
      if(!stopPad) return;
      while (stopPad.firstChild) stopPad.removeChild(stopPad.firstChild);
      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS,'svg');
      svg.setAttribute('viewBox','0 0 24 24');
      svg.classList.add('w-7','h-7');
      svg.setAttribute('fill','none');
      svg.setAttribute('stroke','#0F2027');
      svg.setAttribute('stroke-width','2.4');
      svg.setAttribute('stroke-linecap','round');
      svg.setAttribute('stroke-linejoin','round');
      const chevron1 = document.createElementNS(NS,'path');
      chevron1.setAttribute('d','M13.5 6l-6 6 6 6');
      const chevron2 = document.createElementNS(NS,'path');
      chevron2.setAttribute('d','M18 6l-6 6 6 6');
      svg.append(chevron1, chevron2);
      stopPad.appendChild(svg);
    }

    function setStopSquareIcon(stopPad){
      if(!stopPad) return;
      while (stopPad.firstChild) stopPad.removeChild(stopPad.firstChild);
      const NS = 'http://www.w3.org/2000/svg';
      const sq = document.createElementNS(NS,'svg');
      sq.setAttribute('viewBox','0 0 24 24');
      sq.classList.add('w-7','h-7');
      const rect = document.createElementNS(NS,'rect');
      rect.setAttribute('x','4');
      rect.setAttribute('y','4');
      rect.setAttribute('width','16');
      rect.setAttribute('height','16');
      rect.setAttribute('fill','#222');
      sq.appendChild(rect);
      stopPad.appendChild(sq);
    }

    function setDownloadIcon(btn){
      if(!btn) return;
      while (btn.firstChild) btn.removeChild(btn.firstChild);
      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS,'svg');
      svg.setAttribute('viewBox','0 0 24 24');
      svg.classList.add('w-7','h-7');
      svg.setAttribute('fill','none');
      svg.setAttribute('stroke','#0F2027');
      svg.setAttribute('stroke-width','2.2');
      svg.setAttribute('stroke-linecap','round');
      svg.setAttribute('stroke-linejoin','round');
      const arr = document.createElementNS(NS,'path');
      arr.setAttribute('d','M12 5v10m0 0l-4-4m4 4l4-4');
      const base = document.createElementNS(NS,'path');
      base.setAttribute('d','M5 19h14');
      svg.append(arr, base);
      btn.appendChild(svg);
    }

    function setFolderIcon(btn){
      if(!btn) return;
      while (btn.firstChild) btn.removeChild(btn.firstChild);
      btn.insertAdjacentHTML('afterbegin', '<svg viewBox="0 0 24 24" class="w-7 h-7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7h5l2 3h11v9H3z"/><path d="M3 7v12"/></svg>');
    }

    function bindDownloadButton(btn, taskRef){
      if(!btn || !taskRef || !taskRef.id) return;
      btn.classList.add('show');
      setDownloadIcon(btn);
      btn.title = 'download';
      guardClick(btn, (e) => {
        e.preventDefault();
        const a = document.createElement('a');
        a.href = '/download/' + taskRef.id;
        a.rel = 'noopener';
        a.download = '';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { try{ a.remove(); }catch(_){}} , 250);
        taskRef.downloaded = true;
        saveTasks();
        setFolderIcon(btn);
        bindFolderButton(btn, taskRef);
      });
    }
// --- Helper to rerun a task server-side ---
    async function rerunTask(task, ui){
      const {bar, st, dl, stopPad, smooth} = ui;
      if(!task || !task.id) return;
      let ok = false, newId = null, payload = null;
      try {
        const res = await fetch('/rerun/' + task.id, { method: 'POST' });
        if (res.ok) {
          try { payload = await res.json(); } catch(_) { payload = null; }
          newId = payload && (payload.task_id || payload.id || null);
          if (newId) { ok = true; }
        }
      } catch (_) {}
      if (!ok || !newId) {
        // Treat it as a stopped/error card with rerun available
        if (st) { showStatus(st); st.textContent = 'error'; st.classList.remove('hidden'); setStatusVisibility(st, 'error'); }
        const parent = st && st.closest ? st.closest('.card') : null;
        if (parent) parent.classList.add('done');

        if (stopPad) {
          stopPad.title = 'rerun';
          stopPad.innerHTML = '';          // prevent double icon
          setRetryIcon(stopPad);
          stopPad.style.pointerEvents = '';
          stopPad.style.opacity = '';
          guardClick(stopPad, (e) => { e.preventDefault(); rerunTask(task, ui); });
        }
        updateUI();
        showError('rerun failed');
        return;
      }
      // reset visual state
      if(st){ showStatus(st); st.classList.remove('hidden'); st.textContent = 'preparing (0%)'; setStatusVisibility(st, 'preparing'); }
      if(dl){ dl.classList.remove('show'); dl.removeAttribute('href'); }
      const card = stopPad && stopPad.closest('.card');
      if(card){ card.classList.remove('done'); }
      if(smooth){ smooth.setImmediate(0); }
      // show stop square again
      if(stopPad){
        stopPad.title = 'stop';
        stopPad.innerHTML = '';
        setStopSquareIcon(stopPad);
        stopPad.style.pointerEvents = '';
        stopPad.style.opacity = '';
        guardClick(stopPad, async (e) => {
          if(stopPad.dataset.busy === '1') return;
          stopPad.dataset.busy = '1';
          e.preventDefault();
          try{ await fetch('/stop/'+task.id,{method:'POST'}); }catch(_){ }
          setTimeout(() => { stopPad.dataset.busy = ''; }, 250);
        });
        setStopVisibility(stopPad, 'preparing');
      }
      task.stage = 'preparing';
      task.pct = 0;
      task.downloaded = false;
      saveTasks();
      updateUI();
      // resume tracking
      const oldId = task.id;
      task.id = newId;
      if (dl) { dl.removeAttribute('href'); }
      const row = stopPad && stopPad.closest('.item-row');
      if (row) { row.__taskId = newId; }
      saveTasks();
      trackProgress(newId, bar, st, dl, null, null, task, null, smooth, stopPad);
    }

    function createItem(task){
      const node = template.content.cloneNode(true);
      const li   = node.querySelector('.filename');
      const bar  = node.querySelector('.bar-fill');
      const st   = node.querySelector('.chip');
      const dl   = node.querySelector('.dl-pad');
      const card = node.querySelector('.card');
      const stopPad = node.querySelector('.stop-pad');
      li.textContent = task.name;
      const labels = node.querySelector('.labels');
      const smooth = makeProgressSmoother(bar);
      const initOverall = Math.max(0, Math.min(100, task.pct || 0));
      smooth.setImmediate(initOverall);
      if(task.stage === 'done'){
        hideStatus(st);
        dl.classList.add('show');
        dl.title = 'open folder';
        bindFolderButton(dl, task);
        card.classList.add('done');
        if(stopPad) stopPad.remove();
      }
      else if(task.stage === 'stopped'){
        // Treat as finished visually
        showStatus(st);
        st.classList.add('hidden');
        card.classList.add('done');
        if (stopPad){
          stopPad.style.display = '';
          stopPad.classList.add('show');
          stopPad.innerHTML = '';
          setRetryIcon(stopPad);
          stopPad.title = 'rerun';
        guardClick(stopPad, (e) => { e.preventDefault(); rerunTask(task, { bar, st, dl, stopPad, smooth }); });
      }
      }
      else if (task.stage === 'error' || task.pct < 0) {
        // Treat like stopped; keep label visible for context
        showStatus(st);
        st.textContent = 'error';
        const parent = st.closest('.card'); if (parent) parent.classList.add('done');
        if (stopPad){
          stopPad.style.display = '';
          stopPad.classList.add('show');
          stopPad.title = 'rerun';
          stopPad.innerHTML = '';
          setRetryIcon(stopPad);
        guardClick(stopPad, (e) => { e.preventDefault(); rerunTask(task, { bar, st, dl, stopPad, smooth }); });
      }
      }
      else {
        const sp = Math.round(Math.max(0, Math.min(100, task.pct)));
        showStatus(st);
        st.textContent = task.stage ? `${displayStage(task.stage)} (${sp}%)` : 'queued';
        smooth.setImmediate(sp);
        setStopVisibility(stopPad, task.stage);
      }
      if(task.stage !== 'done' && dl && !isProcessing(task)){
        dl.classList.add('show');
        dl.title = 'retry';
        dl.innerHTML = '';
        setRetryIcon(dl);
        guardClick(dl, (e) => { e.preventDefault(); rerunTask(task, { bar, st, dl, stopPad, smooth }); });
      }
      setStatusVisibility(st, task.stage);
      const inserted = node.children[0];
      inserted.classList.add('enter-pre');
      // Attach task id for later filtering
      inserted.__taskId = task.id;
      queue.insertBefore(inserted, queue.firstChild);
      // apply enter transition to the inserted card
      requestAnimationFrame(() => {
        inserted.classList.add('enter-active');
      });
      // Apply any stem labels if present
      applyLabels(inserted.querySelector('.labels'), task.stems);
      updateClear();
      updateVigs();
      updateStartButton();
      return {bar, st, dl, stopPad, smooth};
    }

    function withPageFade(doWork){
      const mask = document.createElement('div');
      mask.className = 'page-mask';
      document.body.appendChild(mask);
      requestAnimationFrame(() => {
        mask.classList.add('show');
        setTimeout(() => {
          try { doWork(); } finally {
            mask.classList.remove('show');
            setTimeout(() => mask.remove(), 300);
          }
        }, 280);
      });
    }

    function closeActiveStreams(){
      activeStreams.forEach((stream) => {
        try{ stream.close(); } catch(_){}
      });
      activeStreams.clear();
    }

    function abortPendingUploads(){
      pendingItems.forEach((pending) => {
        if(pending && pending.xhr){
          try{ pending.xhr.abort(); } catch(_){}
        }
      });
    }

    async function clearAllTasks({ showToast = false } = {}){
      if(isClearing) return;
      isClearing = true;
      closeActiveStreams();
      abortPendingUploads();
      if(Array.isArray(tasks)){
        tasks.forEach(t => {
          if(t && t.id){
            try { fetch('/stop/' + t.id, {method:'POST'}); } catch(_){}
          }
        });
      }
      for (const el of Array.from(queue.children)) { el.remove(); }
      tasks = [];
      pendingItems.length = 0;
      startLock = false;
      startPressed = false;
      saveTasks();
      updateUI();
      try { await fetch('/clear_all_uploads', {method:'POST'}); } catch(_){ }
      isClearing = false;
      if(showToast) showPopup('all tasks cleared');
    }

    guardClick(clearBtn, async () => {
      const hasRunning = Array.isArray(tasks) && tasks.some(t => isProcessing(t));
      if(hasRunning){
        const ok = await showConfirm('A process is still running. Clear all anyway?');
        if(!ok) return;
      }
      clearAllTasks();
    });

    rehydrateTasks().finally(() => {
      // restore previous tasks
      tasks.forEach(t => {
        const {bar, st, dl, stopPad, smooth} = createItem(t);
        const last = queue.lastElementChild;
        if(last){
          requestAnimationFrame(() => {
            last.classList.add('enter-active');
          });
        }
        if(t.id && t.pct < 100 && t.pct >= 0){
          trackProgress(t.id, bar, st, dl, null, null, t, null, smooth, stopPad);
        }
      });
      updateUI();
      window.addEventListener('scroll', updateVigs);
    });
    // settings button → open overlay
    const settingsBtn = document.getElementById('settings-btn');
    if(settingsBtn){ settingsBtn.addEventListener('click', openSettings); }

    // initialize overlay controls on load
    window.addEventListener('load', () => {
      settingsOverlay = document.getElementById('settings-overlay');
      const closeBtn = document.getElementById('settings-close');
      const forceBtn = document.getElementById('force-clear');
      if(closeBtn) closeBtn.addEventListener('click', closeSettings);
      if(settingsOverlay) settingsOverlay.addEventListener('click', (e)=>{ if(e.target === settingsOverlay) closeSettings(); });
      if(forceBtn) forceBtn.addEventListener('click', async ()=>{
        try{
          await clearAllTasks({ showToast: true });
          closeSettings();
        }catch(err){ showError('force clear failed'); }
      });
      checkStorage();
      checkMemory();
      setInterval(checkStorage, 15000);
      setInterval(checkMemory, 12000);
      loadSettings();
      persistSettings({ structure_mode: 'flat' }, { showMissingPopup:false });
      if(outputInput){
        // output selection disabled
      }
      if(outputChoose){
        // output chooser disabled
      }
      if(structureCheck){
        structureCheck.addEventListener('change', () => {
          if(structureCheck.checked){
            persistSettings({ structure_mode: 'structured' });
          }
        });
      }
      if(structurelessCheck){
        structurelessCheck.addEventListener('change', () => {
          if(structurelessCheck.checked){
            persistSettings({ structure_mode: 'flat' });
          }
        });
      }
    });

    // drag-and-drop highlights
    ['dragenter','dragover'].forEach(evt =>
      dropzone.addEventListener(evt, e => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.add('ring-2','ring-[var(--accent)]');
      }));
    ['dragleave','drop'].forEach(evt =>
      dropzone.addEventListener(evt, e => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.remove('ring-2','ring-[var(--accent)]');
      }));

    // open file picker on click/keyboard
    const triggerPicker = () => {
      try {
        if (fileInput.showPicker) { fileInput.showPicker(); return; }
      } catch(_) {}
      fileInput.click();
    };
    dropzone.addEventListener('click', triggerPicker);
    dropzone.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        triggerPicker();
      }
    });

    // handle both dropped and picked files
    dropzone.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
    fileInput.addEventListener('change', e => handleFiles(e.target.files));

    function showError(msg){
      const overlay = document.createElement('div');
      overlay.className = 'fixed inset-0 flex items-center justify-center backdrop-blur-sm';
      overlay.innerHTML = `<div class="glass p-6 rounded-xl flex flex-col gap-4 text-[var(--txt-main)]"><p class="text-center">Upload failed: ${msg}</p><button class="mx-auto px-4 py-1 bg-[var(--accent)] rounded text-black">ok</button></div>`;
      document.body.appendChild(overlay);
      const btn = overlay.querySelector('button');
      btn.onclick = () => overlay.remove();
      overlay.tabIndex = 0; overlay.focus();
      overlay.addEventListener('keydown', e => { if(e.key === 'Enter') btn.click(); });
    }

    function showPopup(msg){
      const card = document.createElement('div');
      card.textContent = msg;
      card.className = 'fixed top-4 right-4 glass px-4 py-2 rounded text-[var(--txt-main)]';
      document.body.appendChild(card);
      setTimeout(() => card.remove(), 3000);
    }

    function showConfirm(msg){
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'fixed inset-0 flex items-center justify-center backdrop-blur-sm';
        overlay.innerHTML = `
          <div class="glass p-6 rounded-xl flex flex-col gap-4 text-[var(--txt-main)] max-w-sm w-11/12">
            <p class="text-center">${msg}</p>
            <div class="flex justify-center gap-3">
              <button id="cfm-cancel" class="px-3 py-1 bg-gray-600 rounded">cancel</button>
              <button id="cfm-ok" class="px-3 py-1 bg-[var(--accent)] text-black rounded">ok</button>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        const ok = overlay.querySelector('#cfm-ok');
        const cancel = overlay.querySelector('#cfm-cancel');
        const done = (val) => { overlay.remove(); resolve(val); };
        ok.onclick = () => done(true);
        cancel.onclick = () => done(false);
        overlay.addEventListener('keydown', (e) => {
          if(e.key === 'Escape') done(false);
          if(e.key === 'Enter') done(true);
        });
        overlay.tabIndex = 0;
        overlay.focus();
      });
    }

    async function showModelsPopup(onCancel){
      try{
        const res = await fetch('/models_status');
        if(res.ok){
          const data = await res.json();
          if(Array.isArray(data.missing) && data.missing.length === 0){
            return;
          }
        }
      }catch(_){}
      const declined = localStorage.getItem('declinedModels');
      const msg = declined ? "you didn't put the models in :(" : 'models not found! would you like me to download them?';
      const yes = declined ? 'download' : 'yes please';
      const overlay = document.createElement('div');
      overlay.className = 'fixed inset-0 flex items-center justify-center backdrop-blur-sm';
      overlay.innerHTML = `<div class="glass p-6 rounded-xl flex flex-col gap-2 text-[var(--txt-main)]"><p>${msg}</p><div class="flex justify-end gap-2"><button id="no-btn" class="px-3 py-1 bg-gray-500 rounded">nah i still got it</button><button id="yes-btn" class="px-3 py-1 bg-[var(--accent)] rounded text-black">${yes}</button></div></div>`;
      document.body.appendChild(overlay);
      const noBtn = overlay.querySelector('#no-btn');
      const yesBtn = overlay.querySelector('#yes-btn');
      noBtn.onclick = () => { localStorage.setItem('declinedModels','1'); overlay.remove(); if(onCancel) onCancel(); updateUI(); };
      yesBtn.onclick = () => { localStorage.removeItem('declinedModels'); fetch('/download_models', {method:'POST'}); overlay.remove(); };
      overlay.tabIndex = 0; overlay.focus();
      overlay.addEventListener('keydown', e => { if(e.key === 'Enter') yesBtn.click(); });
    }

    /* === upload & progress logic === */
    // queue of files added by user but not yet uploaded
    const pendingItems = [];
    const activeStreams = new Map();
    let isClearing = false;
    function dropPendingById(id){
      if(!id) return;
      const idx = pendingItems.findIndex(p => p && p.id === id);
      if(idx >= 0) pendingItems.splice(idx,1);
    }
    function getTaskById(id){
      return tasks.find(t => t && t.id === id);
    }

    function getTaskByTempKey(tempKey){
      if(!tempKey) return null;
      return tasks.find(t => t && t.tempKey === tempKey);
    }

    function revealStatusesAfterStart(){
      document.querySelectorAll('#queue .chip').forEach(chip => chip.classList.remove('hidden'));
      document.querySelectorAll('#queue .stop-pad').forEach(pad => {
        const row = pad.closest('.item-row');
        const id = row ? row.__taskId : null;
        const tempKey = row ? row.__tempKey : null;
        const task = id ? getTaskById(id) : getTaskByTempKey(tempKey);
        const stage = task ? task.stage : null;
        setStopVisibility(pad, stage);
      });
    }

    function selectedStems(){
      const stems = [];
      if(vocalsBox.checked) stems.push('vocals');
      if(instBox.checked)   stems.push('instrumental');
      if(deuxBox && deuxBox.checked) stems.push('deux');
      return stems;
    }

    async function handleFiles(fileList){
      const storageOk = await checkStorage();
      const memoryOk = checkMemory();
      if(!storageOk || !memoryOk){
        showPopup('cannot add songs until resources are available');
        return;
      }
      const existingCount = tasks.filter(Boolean).length;
      if(existingCount >= MAX_TASKS){
        showPopup('you already have 50 songs queued; clear some to upload more');
        return;
      }
      const makeTempKey = () => (crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random()));
      const stems = selectedStems();
      const newPending = [];
      const files = [...fileList];
      const audioFiles = files.filter((file) => {
        return (file.type && file.type.startsWith('audio/')) || /\.(wav|wave|mp3|m4a|aac|flac|ogg|oga|aif|aiff)$/i.test(file.name);
      });
      if(existingCount + audioFiles.length > MAX_TASKS){
        const slots = Math.max(0, MAX_TASKS - existingCount);
        const slotLabel = slots === 1 ? 'song' : 'songs';
        showPopup(`you can only add ${slots} more ${slotLabel} (max 50 total)`);
        return;
      }
      let availableSlots = Math.max(0, MAX_TASKS - existingCount);
      for(const file of files){
        if(availableSlots <= 0) break;
        // accept common audio even when type is empty
        const looksAudio = (file.type && file.type.startsWith('audio/')) || /\.(wav|wave|mp3|m4a|aac|flac|ogg|oga|aif|aiff)$/i.test(file.name);
        if(!looksAudio) continue;

        const duration = await getAudioDuration(file);
        if(duration > 0){
          if(duration > FIVE_HOURS_SEC){
            showPopup('single song limit is 5 hours');
            continue;
          }
          if(duration > LONG_TRACK_SEC && !hasMemoryForDuration(duration)){
            continue;
          }
        }

        const tempKey = makeTempKey();
        availableSlots -= 1;
        // build UI row (ready state)
        const frag = template.content.cloneNode(true);
        const item = frag.firstElementChild;
        const li   = item.querySelector('.filename');
        const bar  = item.querySelector('.bar-fill');
        const st   = item.querySelector('.chip');
        const dl   = item.querySelector('.dl-pad');
        const card = item.querySelector('.card');
        const stopPad = item.querySelector('.stop-pad');
        li.textContent = file.name;
        st.textContent = 'ready';
        st.classList.add('chip-dim');
        st.classList.add('hidden');
        if(startPressed){ st.classList.remove('hidden'); }
        dl.classList.remove('show');
        if (stopPad) stopPad.style.display = 'none';
        item.classList.add('enter-pre');
        item.__tempKey = tempKey;
        queue.insertBefore(item, queue.firstChild);
        requestAnimationFrame(() => {
          item.classList.add('enter-active');
        });
        updateVigs();
        const smooth = makeProgressSmoother(bar);
        smooth.setImmediate(0);
        // record pending entry
        const pending = { file, ui:{item, li, bar, st, dl, card, stopPad, smooth}, started:false, id:null, stems:null, tempKey, autoStart:startPressed, startedProcessing:false };
        pendingItems.push(pending);
        newPending.push(pending);
        // persist placeholder task (no id yet)
        tasks.push({ id:null, name:file.name, pct:0, stage:'ready', stems:[], file:null, tempKey, out_dir:null, downloaded:false });
        saveTasks();
        updateUI();
      }
      if (fileInput) fileInput.value = '';

      if(newPending.length && stems.length === 0){
        showPopup('please select at least one stem before uploading');
        return;
      }

      for(const p of newPending){
        if(!p.started){
          await uploadWithStems(p, stems);
        }
      }
      updateStartButton();
    }

    function uploadWithStems(pending, stems){
      pending.started = true;
      pending.uploadPromise = new Promise((resolve) => {
        const {file, ui} = pending;
        const {st, dl, card, stopPad, bar, smooth} = ui;
        const data = new FormData();
        data.append('file', file);
        data.append('stems', stems.join(','));
        const xhr = new XMLHttpRequest();
        pending.xhr = xhr;
        xhr.open('POST', '/upload');
        xhr.upload.onprogress = (evt) => {
          if(evt.lengthComputable){
            const pct = Math.round(evt.loaded / evt.total * 100);
            st.textContent = `uploading (${pct}%)`;
            st.classList.remove('chip-dim');
          }
        };
        xhr.onload = () => {
          if(xhr.status >= 400){ showStatus(st); st.classList.remove('hidden'); st.textContent = 'error'; return resolve(); }
          st.classList.remove('chip-dim');
          st.textContent = 'ready';
          smooth.setImmediate(0);
          let res = {};
          try {
            res = JSON.parse(xhr.responseText || '{}');
            const msg = res.detail && res.detail.message;
            if(msg){
              showStatus(st);
              st.textContent = 'error';
              st.classList.add('chip-dim');
              if (stopPad) stopPad.style.display = 'none';
              else showError(msg);
            }
          }catch(_){ }
          if(res.detail && res.detail.message){
            try{
              const msg = res.detail.message;
              showStatus(st); st.textContent = 'error'; st.classList.add('chip-dim'); if(stopPad) stopPad.style.display = 'none';
              else showError(msg);
            }catch(_){ }
            return resolve();
          }
          const parsed = JSON.parse(xhr.responseText);
          pending.id = parsed.task_id;
          pending.stems = parsed.stems;
          ui.item.__taskId = parsed.task_id;
          // replace placeholder task
          const idx = tasks.findIndex(t => t.tempKey === pending.tempKey);
          const t = { id:parsed.task_id, name:file.name, pct:0, stage:'ready', stems:parsed.stems, tempKey: pending.tempKey, out_dir: null, downloaded:false };
          if(idx>=0) tasks[idx]=t; else tasks.push(t);
          if(startPressed || pending.autoStart){
            t.stage = 'queued';
            t.pct = 0;
            if(st){
              showStatus(st);
              st.textContent = 'queued';
              st.classList.remove('hidden');
            }
          }
          saveTasks(); updateUI();
          // enable stop now that we have an id
          if (stopPad){
            setStopSquareIcon(stopPad);
            stopPad.style.pointerEvents = '';
            stopPad.style.opacity = '';
            stopPad.title = 'stop';
            guardClick(stopPad, async (e) => {
              if(stopPad.dataset.busy === '1') return;
              stopPad.dataset.busy = '1';
              e.preventDefault();
              try{ await fetch('/stop/'+parsed.task_id,{method:'POST'}); }catch(_){ /* ignore */ }
              // mark as stopped locally so UI updates right away
              t.stage = 'stopped';
              t.pct = 0;
              saveTasks();
              // update visuals
              if(st){ showStatus(st); st.textContent = 'stopped'; st.classList.remove('hidden'); }
              const parent = st && st.closest('.card');
              if(parent){ parent.classList.add('done'); }
              // swap to rerun icon+handler
              if(stopPad){
                stopPad.style.pointerEvents = '';
                stopPad.style.opacity = '';
                stopPad.title = 'rerun';
                setRetryIcon(stopPad);
                guardClick(stopPad, (ev) => { ev.preventDefault(); rerunTask(t, { bar, st, dl, stopPad, smooth }); });
              }
              stopPad.dataset.busy = '';
              updateUI();
            });
            setStopVisibility(stopPad, 'ready');
          }
          // start polling
          trackProgress(res.task_id, ui.bar, ui.st, ui.dl, null, null, t, null, smooth, stopPad);
          if(pending.autoStart){
            startTaskWhenReady(pending);
          }
          resolve();
        };
        xhr.onerror = () => { showStatus(st); st.classList.remove('hidden'); st.textContent = 'error'; resolve(); };
        xhr.send(data);
      });
      return pending.uploadPromise;
    }

    function startTaskWhenReady(pending){
      if(!pending || pending.startedProcessing) return;
      if(!pending.uploadPromise){ return; }
      pending.startedProcessing = true;
      pending.uploadPromise.then(async () => {
        if(!pending.id) return;
        try{ await fetch('/start/' + pending.id, { method:'POST' }); }catch(_){ /* ignore */ }
      });
    }

    async function startSequentialProcessing(){
      if(startLock || (startBtn && startBtn.disabled)) return;
      const storageOk = await checkStorage();
      const memoryOk = checkMemory();
      if(!storageOk || !memoryOk){
        showPopup('cannot start until storage and memory are sufficient');
        return;
      }
      startLock = true;
      updateStartButton();
      let markedStarted = false;
      const markReadyQueuedUI = () => {
        const rows = Array.from(queue.children);
        let changed = false;
        rows.forEach(row => {
          const id = row.__taskId;
          const tempKey = row.__tempKey;
          const task = id ? getTaskById(id) : getTaskByTempKey(tempKey);
          const chip = row.querySelector('.chip');
          if(task && (!task.stage || task.stage === 'ready' || task.stage === 'queued')){
            if(task.stage !== 'queued' || task.pct !== 0){
              task.stage = 'queued';
              task.pct = 0;
              changed = true;
            }
            if(chip){
              showStatus(chip);
              chip.textContent = 'queued';
              chip.classList.remove('hidden');
            }
            return;
          }
          if(chip && (chip.textContent || '').toLowerCase() === 'ready'){
            showStatus(chip);
            chip.textContent = 'queued';
            chip.classList.remove('hidden');
          }
        });
        if(changed){
          saveTasks();
        }
      };
      const startReadyTasks = async () => {
        const ready = Array.isArray(tasks)
          ? tasks.filter(t => t && t.id && (!t.stage || t.stage === 'ready' || t.stage === 'queued'))
          : [];
        for(const t of ready){
          try{
            await fetch('/start/' + t.id, { method:'POST' });
            t.stage = 'queued';
            t.pct = 0;
            if(typeof t.downloaded === 'undefined'){ t.downloaded = false; }
          }catch(_){}
        }
        saveTasks();
        markReadyQueuedUI();
      };
      try{
        const stems = selectedStems();
        if(stems.length === 0){
          showPopup('please select at least one stem');
          return;
        }
        startGeneration += 1;
        startPressed = true;
        markedStarted = true;
        markReadyQueuedUI();
        let startIndex = 0;
        revealStatusesAfterStart();
        while(startIndex < pendingItems.length){
          const p = pendingItems[startIndex];
          startIndex += 1;
          if(p){ p.autoStart = true; }
          if(!p.uploadPromise){
            await uploadWithStems(p, stems);
          }
          if(p.uploadPromise){
            await p.uploadPromise;
          }
          startTaskWhenReady(p);
        }
        await startReadyTasks();
        startPressed = false;
        markedStarted = false;
        pendingItems.forEach(p => { if(p){ p.autoStart = false; } });
        updateUI();
      } finally {
        if(markedStarted){
          startPressed = false;
        }
        startLock = false;
        updateStartButton();
      }
    }
    if(startBtn) guardClick(startBtn, startSequentialProcessing);

    // --- Progress tracking for uploads (SSE) ---
    function displayStage(stage){
      if(!stage) return 'queued';
      const lower = stage.toLowerCase();
      if(lower.includes('deux')) return 'voc/inst';
      if(lower.includes('vocals')) return 'vocals';
      if(lower.includes('instrumental')) return 'instrumental';
      if(lower.includes('drums')) return 'drums';
      if(lower.includes('bass')) return 'bass';
      if(lower.includes('other')) return 'other';
      if(lower.includes('guitar')) return 'guitar';
      if(lower.includes('error')) return 'error';
      if(lower.startsWith('prepare')) return 'preparing';
      if(lower.startsWith('load_audio')) return 'loading';
      if(lower.startsWith('write')) return 'finishing';
      const parts = lower.split('.');
      return parts[parts.length-1] || lower;
    }

    function trackProgress(taskId, bar, st, dl, _a, _b, taskRef, _c, smooth, stopPad){
      try{
        const es = new EventSource('/progress/' + taskId);
        activeStreams.set(taskId, es);
        es.addEventListener('message', (ev) => {
          if(isClearing) return;
          let data = null;
          try { data = JSON.parse(ev.data); } catch(_) {}
          if(!data) return;
          const rawStage = data.stage;
          const stage = rawStage === 'errored' ? 'error' : rawStage;
          const pct = data.pct;
          if(taskRef){
            taskRef.stage = stage;
            taskRef.pct = pct;
            if(data.stems) taskRef.stems = data.stems;
            if(data.out_dir) taskRef.out_dir = data.out_dir;
            if(data.zip) taskRef.zip = data.zip;
            if(typeof taskRef.downloaded === 'undefined'){ taskRef.downloaded = false; }
            saveTasks();
          }
          if(data.stems && st){
            const parentRow = st.closest('.item-row');
            applyLabels(parentRow ? parentRow.querySelector('.labels') : null, data.stems);
          }
          if(st){ showStatus(st); }
          if(stage === 'done'){
            smooth.setTarget(100);
            hideStatus(st);
            if(dl){
              const ref = taskRef || { id: taskId, out_dir: data.out_dir, zip: data.zip, downloaded:false };
              if(ref.downloaded){
                setFolderIcon(dl);
                dl.classList.add('show');
                dl.title = 'open folder';
                bindFolderButton(dl, ref);
              }else{
                bindDownloadButton(dl, ref);
              }
            }
            if(stopPad) stopPad.remove();
            const parent = st.closest('.card'); if(parent) parent.classList.add('done');
            dropPendingById(taskId);
            es.close();
            activeStreams.delete(taskId);
            updateUI(); return;
          }
          if (stage === 'stopped') {
            if (taskRef) { taskRef.stage = 'stopped'; taskRef.pct = 0; saveTasks(); }
            showStatus(st);
            st.textContent = 'stopped';
            st.classList.remove('hidden');
            const parent = st.closest('.card'); if (parent) parent.classList.add('done');
            if (stopPad) {
              stopPad.style.display = '';
              stopPad.classList.add('show');
              stopPad.title = 'rerun';
              stopPad.innerHTML = '';
              setRetryIcon(stopPad);
              guardClick(stopPad, (e) => { e.preventDefault(); rerunTask(taskRef, { bar, st, dl, stopPad, smooth }); });
            }
            dropPendingById(taskId);
            es.close();
            activeStreams.delete(taskId);
            updateUI(); return;
          }
          if (typeof pct === 'number' && pct >= 0) {
            const sp = Math.round(Math.max(0, Math.min(100, pct)));
            const friendlyStage = displayStage(stage);
            if (stage === 'queued' || stage === 'ready') {
              st.textContent = friendlyStage || 'queued';
              smooth.setImmediate(0);
            } else {
              st.textContent = friendlyStage ? `${friendlyStage} (${sp}%)` : `${sp}%`;
              smooth.setTarget(sp);
            }
            if(stage !== 'done' && dl){
              dl.classList.remove('show');
            }
          } else {
            st.textContent = 'queued';
          }
          setStatusVisibility(st, stage);
          setStopVisibility(stopPad, stage);
        });
        es.addEventListener('error', (ev) => {
          if (taskRef && taskRef.stage === 'stopped') {
            es.close();
            activeStreams.delete(taskId);
            updateUI();
            return;
          }
          let errPayload = null;
          let errCode = null;
          let errMsg = null;
          try{
            if(ev && ev.data){ errPayload = JSON.parse(ev.data); }
          }catch(_){}
          if(errPayload){
            errCode = errPayload.code || (errPayload.detail && errPayload.detail.code);
            errMsg = errPayload.message || (errPayload.detail && errPayload.detail.message);
          }
          if (taskRef) {
            taskRef.stage = 'error';
            taskRef.pct = -1;
            saveTasks();
          }
          if (st) {
            showStatus(st);
            st.textContent = 'error';
            st.classList.remove('hidden');
          }
          setStatusVisibility(st, 'error');
          const parent = st && st.closest ? st.closest('.card') : null;
          if (parent) parent.classList.add('done');

          if (stopPad) {
            stopPad.style.display = '';
            stopPad.classList.add('show');
            stopPad.title = 'rerun';
            stopPad.innerHTML = '';
            setRetryIcon(stopPad);
            guardClick(stopPad, (e) => {
              e.preventDefault();
              if (taskRef) rerunTask(taskRef, { bar, st, dl, stopPad, smooth });
            });
          }
          dropPendingById(taskId);
          es.close();
          activeStreams.delete(taskId);
          if(errCode === 'E004'){
            showModelsPopup();
          }else if(errMsg){
            showPopup(errMsg);
          }
          updateUI();
        });
              }catch(e){
        showStatus(st);
        st.textContent = 'error';
        if(taskRef){ taskRef.stage = 'error'; taskRef.pct = -1; saveTasks(); }
        updateUI();
      }
    }
</script>

  <div id="settings-overlay" class="hidden fixed inset-0 z-50 grid place-items-center">
    <!-- Animated background blur+dim layer -->
    <div id="overlay-bg" class="overlay-bg"></div>

    <!-- The modal card itself -->
    <div id="settings-card"
         class="glass w-11/12 max-w-md p-6 rounded-2xl text-[var(--txt-main)] relative opacity-0"
         style="backdrop-filter: blur(8px) saturate(110%); -webkit-backdrop-filter: blur(8px) saturate(110%); background: rgba(23,35,41,0.45);">
      <button id="settings-close" title="close" class="absolute top-3 right-3 p-2 rounded hover:bg-white/10">✕</button>
      <h2 class="text-2xl font-light mb-3 select-none">settings</h2>

      <div class="flex flex-col gap-3">
        <div class="space-y-2">
          <div class="text-sm opacity-80">outputs will be saved as a zip to your Downloads folder</div>
        </div>

        <div class="border-t border-white/10 my-4"></div>

        <div class="flex flex-col gap-3">
          <button id="force-clear" class="btn bg-white text-black px-1 py-2 text-xs" style="border-radius:12px;">force clear</button>
          <div class="text-xs opacity-60">Stops all processing, removes all items, and clears uploaded files.</div>
        </div>
        <div class="border-t border-white/10 my-4"></div>

        <div class="flex gap-3 mt-3">
          <a href="https://github.com/Skytheredhead/stemsplat" target="_blank" rel="noopener noreferrer" class="btn bg-white text-black px-1 py-2 text-xs flex-1 text-center" style="border-radius:12px;">github</a>
          <a href="https://forms.gle/wSpe2nyFgcmuxSr28" target="_blank" rel="noopener noreferrer" class="btn bg-white text-black px-1 py-2 text-xs flex-1 text-center" style="border-radius:12px;">bugs/feedback</a>
        </div>
        <div class="text-xs opacity-70 text-center"><a href="https://huggingface.co/becruily" target="_blank" rel="noopener noreferrer" class="underline">models by becruily</a></div>
      </div>

      <div class="mt-6 text-center opacity-70 text-sm">v0.1</div>
    </div>
  </div>
